                                     GRADER

Name of student running submit: Yuxin Zhu
Login of student running submit: cs61b-un

Second team member's name: Sanchit Bareja
Second team member's login: cs61b-gs

Third team member's name (if any): Noah Gilmore
Third team member's login: cs61b-gx

IMPORTANT:  Once you've submitted Project 2 once, the same team member should
submit always.  If a different teammate must submit, inform cs61b@cory.eecs of
all the details.  Include a complete list of team members, and let us know
which submission you want graded.

If you've submitted your project once, or even written a substantial amount of
code together, you may not change partners without the permission of the
instructor.
===============================================================================
Does your program compile without errors?


Have you tested your program on the machines in the Soda CS 61B lab?


Did you successfully implement game tree search?  Did you successfully
implement alpha-beta pruning?  Are there any limitations on it?  What is the
default number of search levels set by the one-parameter MachinePlayer
constructor?


Describe your board evaluation function in some detail.


Does your MachinePlayer use any special method of choosing the first few moves?


Is there anything else the graders should know to help them read your project?



Describe the classes, modules, and interfaces you designed before and while you
implemented the project.  Your description should include:
  -  A list of the classes your program uses.
  -  A list of each of the "modules" used in or by MachinePlayer, similar to
     the list in the "Teamwork" section of the README (but hopefully more
     detailed).
  -  For each module, list the class(es) the module is implemented in.
  -  For each module, say which of your team members implemented it.
  -  For each module, describe its interface--specifically, the prototype and
     behavior of each method that is available for external callers (outside
     the module) to call.  Don't include methods that are only meant to be
     called from within the module.

     For each method, provide (1) a method prototype and (2) a complete,
     unambiguous description of the behavior of the method/module.  This
     description should also appear before the method in your code's comments.

You will probably need to change some of your design decisions as you go; be
sure to modify this file to reflect these changes before you submit your
project.  Your design of classes and interfaces with be worth about 10% of your
grade.

List of classes:

MachinePlayer.java
Player.java
Move.java

Gameboard.java
Square.java
Evaluator.java

Modules:
1. Determine whether a move is valid (Implemented by Yuxin)
A method in the Gameboard class called isValidMove will take a Move
object as a parameter and check agaist a variety of things, including
whether there is already a piece placed in the intended move position,
whether the intended coordinate is legal, and whether the player
making the move is allowed to add more pieces using methods of the
Square and Gameboard classes. Methods:
	a. public boolean isValidMove(Move m) //Gameboard class

    /**
     * isValidMove() checks if "move" can be legally made based on the game rules.
     * 
     * @param m is the move in question.
     *
     * @return true if the move can be legally made, false otherwise.
     */

    public boolean isvalidMove(Move m) {
    }

2. Generating a list of all valid moves (Implemented by Noah)
A method in the Gameboard class called listMoves will take in an int
representing the color of the player to list the moves for, and will
return a list of Move objects that represent all possible moves for
the player of that color to make. This includes using the isValidMove
module to check whether a move is valid while iterating through a list
of all positions on the board.
	a. public Move[] listMoves(int player) //Gameboard class

    /**
     * listMoves() takes one parameter, the type of the current player, and 
     * returns an array of all possible moves.
     *
     * @param player is the type of the player in consideration
     *
     * @return a Move[] containing all the possible moves possible for "player"
     * "this" Gameboard.
     */

    public Move[] listMoves(int player) {
    }


3. Finding chips that form connections with a chip
(Implemented by Sanchit)
A function called findConnectedChips in the Square class will use the
position of the Square (stored internally), find the Square objects
that represent connections of "this" Square, and return an array of
them. This will make use of the getRow, getColumn, getDiagonal, and
getDiagonalLength methods in Square.
	a. public Square[] findConnectedChips //Square class

    /**
     * findConnectingChips() returns a list of square objects 
     * that "this" Square is "connected" to.
     *
     * @return a Square[] containing chips that "this" Square is connected to
     */

    public Square[] findConnectingChips() {
    }

    /**
     * getRow() takes no parameters, and returns an array of square objects
     * in the same row as "this" Square.
     *
     * @return a Square[] containing squares in the same row as "this" Square.
     */

    public Square[] getRow() {
    }

    /**
     * getColumn takes no parameters, and returns an array of square objects
     * in the same column as "this" Square.
     *
     * @return a Square[] containing squares in the same row as "this" Square.
     */

    public Square[] getColumn() {
    }

    /**
     * getDiagonalLength() takes no parameters, and returns an integer
     * representing the number of valid square objects in the same diagonal
     * as "this" regardless of direction.
     *
     * @return an integer representing the length of the diagonal
     */

    public getDiagonalLength() {
    }

    /**
     * getDiagonal() takes one parameter, a direction, and returns
     * an array of square objects in the same diagonal as "this"
     * Square.
     *
     * @param direction is an integer representing the direction of the diagonal to
     * return. More specifically, a -1 represents a northwest-southeast diagonal, 
     * and a 1 represents a northeast-southwest diagonal.
     *
     * @return a Square[] containing squares in the same diagonal as "this" Square.
     */

    public Square[] getDiagonal(int direction) {
    }


4. Determining whether a player has a network in the gameboard
(Implemented by Sanchit)
A fuction in the gameboard class called containsNetwork will iterate
through the connections of the chips of a certain player in "this"
gameboard and decide if the player has a complete network. Multiple
helper functions will probably need to be added to this module.
	a. public boolean containsNetwork(int player) //Gameboard class

    /**
     * containsNetwork() takes one parameter, the type of the current "player", and
     * returns whether or not a network could be established with the "player"'s
     * pieces on "this" Gameboard
     *
     * @param player is the type of the player in consideration
     *
     * @return true if the current set of pieces contains a Network, false otherwise
     */

    public boolean containsNetwork(int player) {
    }

5. Computing the evaluation function for a board/minimax algorithm
(Implemented by Noah)
A static function called evaluate in the Evaluator class will take a
gameboard as a parameter and perform an algorithmic analysis which
will include an minimax algorithm with alpha-beta pruning. This will
probably need a multitude of helper methods.
	a. public static int evaluate(Gameboard g) //Evaluator class

public class Evaluator {

    /**evaluate() takes one parameter, Gameboard g, and assigns a value between 
     * -1 and 1 to g using a variation of the mini-max alpha-beta pruning algorithm.
     *
     *  @param g is a Gameboard, which is evaluated
     *
     *  @return an int between -1 and 1
     */

    public static int evaluate(Gameboard g) {
        return 1;
    }
}


